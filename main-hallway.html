<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Main Hallway — Team Writers Hub</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --sky-50:#eaf3ff;         /* page bg */
      --sky-100:#e3f2fd;        /* card bg tint */
      --sky-200:#cfe8ff;        /* soft borders */
      --sky-600:#1e88e5;        /* primary */
      --sky-700:#1976d2;        /* primary hover */
      --ink:#0f172a;            /* deep text */
      --muted:#64748b;          /* secondary text */
      --chip:#eef6ff;
      --shadow:0 10px 26px rgba(2, 32, 71, .12);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:"Poppins",system-ui,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
      display:flex;
      background:var(--sky-50);
    }

    /* Sidebar slot */
    #sidebar-container{width:260px;flex:0 0 260px}

    /* App layout */
    .app{flex:1;min-width:0;max-height:100vh;display:grid;grid-template-rows:auto 1fr auto}
    header{
      display:flex;align-items:center;gap:12px;
      padding:14px 18px;background:#fff;border-bottom:1px solid var(--sky-200);
      position:sticky;top:0;z-index:5;
    }
    header h1{margin:0;font-size:22px;font-weight:700;color:#0b305b}
    .role{
      margin-left:auto;display:flex;gap:10px;align-items:center;
      font-size:12px;color:var(--muted)
    }
    .pill{background:var(--chip);padding:6px 10px;border-radius:999px;font-weight:700;color:#195d9b}

    /* Stream */
    .stream{overflow:auto;padding:18px;display:flex;flex-direction:column;gap:14px}
    .card{
      background:#fff;border:1px solid var(--sky-200);border-radius:16px;box-shadow:var(--shadow);
      display:grid;grid-template-columns:auto 1fr;gap:14px;padding:14px 16px;
    }
    .avatar{
      width:40px;height:40px;border-radius:50%;display:grid;place-items:center;
      background:var(--sky-100);color:#195d9b;font-weight:800;border:1px solid var(--sky-200)
    }
    .msg{display:flex;flex-direction:column;gap:8px;min-width:0}
    .meta{display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted)}
    .body{white-space:pre-wrap;word-wrap:break-word;line-height:1.5}
    .body a{color:var(--sky-700);text-decoration:underline;word-break:break-word}

    .attachments{display:flex;flex-wrap:wrap;gap:10px}
    .thumb{
      width:200px;max-width:42vw;height:130px;overflow:hidden;border-radius:12px;border:1px solid var(--sky-200);
      background:var(--sky-100)
    }
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .link-card{
      min-width:260px;max-width:520px;display:flex;align-items:center;gap:10px;
      padding:10px 12px;border-radius:12px;background:var(--sky-100);border:1px solid var(--sky-200)
    }
    .link-card img{width:16px;height:16px;border-radius:4px}
    .actions{margin-left:auto;display:flex;gap:8px}
    .icon-btn{
      background:#fff;border:1px solid var(--sky-200);
      border-radius:10px;color:#143a6b;padding:6px 10px;cursor:pointer
    }
    .icon-btn:hover{background:var(--chip)}

    /* Composer */
    .composer{
      background:#fff;border-top:1px solid var(--sky-200);
      padding:14px 16px;display:grid;grid-template-columns:1fr auto;gap:12px
    }
    .inputs{display:grid;grid-template-rows:auto auto auto;gap:10px}
    textarea{
      width:100%;min-height:64px;max-height:200px;resize:vertical;
      background:var(--sky-100);border:1px solid var(--sky-200);border-radius:12px;
      padding:12px;font-size:14px;color:var(--ink);outline:none
    }
    input[type="url"]{
      width:100%;height:40px;background:var(--sky-100);border:1px solid var(--sky-200);border-radius:12px;
      padding:0 12px;font-size:14px;outline:none
    }
    .btn{height:40px;padding:0 16px;border:none;border-radius:12px;font-weight:800;cursor:pointer}
    .btn-ghost{background:var(--sky-100);border:1px solid var(--sky-200);color:#0b305b}
    .btn-ghost:hover{background:#fff}
    .btn-send{background:var(--sky-700);color:#fff}
    .btn-send:hover{background:#1558b5}

    .previews{display:flex;gap:10px;flex-wrap:wrap}
    .chip{background:var(--chip);border:1px solid var(--sky-200);padding:6px 8px;border-radius:10px;font-size:12px;display:flex;gap:8px;align-items:center}
    .chip button{border:none;background:transparent;color:#0b305b;cursor:pointer}

    .drop{
      border:2px dashed var(--sky-200);border-radius:12px;padding:10px;text-align:center;
      color:var(--muted);transition:all .15s ease;background:var(--sky-100)
    }
    .drop.dragging{background:#fff;color:#113d6e}

    @media (max-width:900px){
      #sidebar-container{display:none}
      .app{grid-template-rows:auto 1fr auto}
    }
  </style>
</head>
<body>
  <!-- Shared Sidebar (reused across pages) -->
  <div id="sidebar-container"></div>

  <!-- App -->
  <div class="app">
    <header>
      <h1>Main Hallway</h1>
      <div class="role">
        <span class="pill" id="user-pill">Anonymous</span>
      </div>
    </header>

    <!-- Messages -->
    <section id="stream" class="stream" aria-live="polite"></section>

    <!-- Composer -->
    <form id="composer" class="composer" autocomplete="off">
      <div class="inputs">
        <textarea id="text" placeholder="Announce something to the hallway… (Shift+Enter = new line)"></textarea>

        <div style="display:grid;grid-template-columns:1fr auto auto;gap:10px;align-items:center">
          <input id="linkInput" type="url" placeholder="Paste a link (https://…)" />
          <label for="file" class="btn btn-ghost" title="Add images">+ Images</label>
          <input id="file" type="file" accept="image/*" multiple hidden>
        </div>

        <div id="drop" class="drop">Drag & drop images or links here</div>
        <div class="previews" id="previews"></div>
      </div>

      <div>
        <button class="btn btn-send" id="sendBtn" type="submit">Post</button>
      </div>
    </form>
  </div>

  <!-- Firebase + App -->
  <script type="module">
    // ----- Load shared sidebar -----
    (function loadSidebar(){
      const c = document.getElementById("sidebar-container");
      fetch("sidebar.html").then(r=>r.text()).then(html=>c.innerHTML=html).catch(()=>{});
    })();

    // ----- Firebase (CDN modular SDK) -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInAnonymously, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
    import {
      getFirestore, collection, addDoc, onSnapshot, query, orderBy, serverTimestamp,
      getCountFromServer, limit, getDocs, doc, deleteDoc, where
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
    import {
      getStorage, ref as sref, uploadBytesResumable, getDownloadURL
    } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-storage.js";

    // TODO: paste your real config
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_AUTH_DOMAIN",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_STORAGE_BUCKET",
      messagingSenderId: "YOUR_MSG_SENDER_ID",
      appId: "YOUR_APP_ID"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    // ----- Simple identity (anonymous, but named) -----
    const userPill = document.getElementById("user-pill");
    onAuthStateChanged(auth, async (u) => {
      if (!u) {
        await signInAnonymously(auth);
        return;
      }
      // Optional: let users set their display name in localStorage (from your profile UI)
      const localName = localStorage.getItem("twh_displayName");
      if (localName && !u.displayName) {
        try { await updateProfile(u, { displayName: localName }); } catch {}
      }
      userPill.textContent = u.displayName || "Anonymous";
    });

    // ----- Message schema & constants -----
    /**
     * Firestore collection: hallwayMessages
     * doc fields:
     *  - uid: string
     *  - author: string
     *  - text: string
     *  - links: string[]
     *  - images: string[] (download URLs)
     *  - createdAt: serverTimestamp
     */
    const COL = collection(db, "hallwayMessages");
    const MAX_MESSAGES = 500;         // soft cap to prevent the UI from getting laggy
    const OPTIONAL_TTL_DAYS = 0;      // set >0 to purge older than N days on load

    // ----- DOM refs -----
    const stream = document.getElementById("stream");
    const form = document.getElementById("composer");
    const text = document.getElementById("text");
    const file = document.getElementById("file");
    const drop = document.getElementById("drop");
    const previews = document.getElementById("previews");
    const linkInput = document.getElementById("linkInput");

    // State for pending attachments
    const pending = { links: [], images: [] };

    // Utils
    function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
    function autoLink(s){
      const urlRe = /(https?:\/\/[^\s)]+)(?![^<]*>)/g;
      return escapeHtml(s).replace(urlRe, '<a href="$1" target="_blank" rel="noopener">$1</a>');
    }
    function fav(url){
      try{ return "https://www.google.com/s2/favicons?domain=" + new URL(url).hostname; }catch{ return ""; }
    }

    // ----- Render stream (realtime) -----
    const qStream = query(COL, orderBy("createdAt", "asc"), limit(MAX_MESSAGES));
    onSnapshot(qStream, (snap) => {
      stream.innerHTML = "";
      snap.forEach(docSnap => {
        const m = docSnap.data();
        const id = docSnap.id;

        const card = document.createElement("article");
        card.className = "card";
        const avatar = document.createElement("div");
        avatar.className = "avatar";
        avatar.textContent = (m.author || "U").slice(0,1).toUpperCase();

        const msg = document.createElement("div");
        msg.className = "msg";

        const meta = document.createElement("div");
        meta.className = "meta";
        const time = m.createdAt?.toDate ? m.createdAt.toDate().toLocaleString() : "sending…";
        meta.innerHTML = `<strong>${escapeHtml(m.author || "Unknown")}</strong><span>•</span><span>${time}</span>`;

        const body = document.createElement("div");
        body.className = "body";
        body.innerHTML = autoLink(m.text || "");

        const atts = document.createElement("div");
        atts.className = "attachments";

        (m.links||[]).forEach(url=>{
          const a = document.createElement("a");
          a.className = "link-card";
          a.href=url; a.target="_blank"; a.rel="noopener";
          const ico=document.createElement("img"); ico.src=fav(url); ico.alt="";
          const span=document.createElement("span");
          span.style.overflow="hidden"; span.style.whiteSpace="nowrap"; span.style.textOverflow="ellipsis";
          span.textContent=url;
          a.appendChild(ico); a.appendChild(span);
          atts.appendChild(a);
        });

        (m.images||[]).forEach(src=>{
          const t = document.createElement("a");
          t.className = "thumb"; t.href=src; t.target="_blank"; t.rel="noopener";
          const img=document.createElement("img"); img.src=src; img.alt="Image";
          t.appendChild(img); atts.appendChild(t);
        });

        const rowTop = document.createElement("div");
        rowTop.style.display="flex"; rowTop.style.alignItems="center"; rowTop.style.gap="8px";
        rowTop.appendChild(meta);

        // Delete if owner
        const actions = document.createElement("div");
        actions.className = "actions";
        const del = document.createElement("button");
        del.className = "icon-btn"; del.textContent = "Delete";
        del.addEventListener("click", async ()=>{
          const u = auth.currentUser;
          if (!u || (u.uid !== m.uid)) return;   // only owners delete (enforce in rules too)
          await deleteDoc(doc(db, "hallwayMessages", id));
        });
        rowTop.appendChild(actions);
        // Only show button if it's the user's own message
        onAuthStateChanged(auth, (u)=>{
          actions.style.display = (u && u.uid === m.uid) ? "flex" : "none";
        });

        msg.appendChild(rowTop);
        if ((m.text||"").trim()) msg.appendChild(body);
        if (atts.children.length) msg.appendChild(atts);

        card.appendChild(avatar);
        card.appendChild(msg);
        stream.appendChild(card);
      });
      stream.scrollTop = stream.scrollHeight;
    });

    // ----- Attachments handling -----
    function refreshPreviews(){
      previews.innerHTML = "";
      // Links
      pending.links.forEach((u,i)=>{
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.innerHTML = `<img src="${fav(u)}" alt="" style="width:14px;height:14px;border-radius:3px"> <span>${u}</span>`;
        const x=document.createElement("button"); x.textContent="✕";
        x.addEventListener("click",()=>{ pending.links.splice(i,1); refreshPreviews(); });
        chip.appendChild(x); previews.appendChild(chip);
      });
      // Images
      pending.images.forEach((name,i)=>{
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.innerHTML = `<span>${name}</span>`;
        const x=document.createElement("button"); x.textContent="✕";
        x.addEventListener("click",()=>{ pending.images.splice(i,1); refreshPreviews(); });
        chip.appendChild(x); previews.appendChild(chip);
      });
    }

    // Link add via input or paste
    linkInput.addEventListener("change", ()=>{
      const v = (linkInput.value||"").trim();
      try{ const u = new URL(v); if(/^https?:$/.test(u.protocol)){ pending.links.push(u.toString()); refreshPreviews(); } }catch(_){}
      linkInput.value="";
    });

    // Images via picker
    file.addEventListener("change", (e)=>{
      [...e.target.files].forEach(f=> pending.images.push(f));
      refreshPreviews();
      file.value="";
    });

    // Drag & drop
    ["dragover","dragenter"].forEach(ev=> drop.addEventListener(ev,e=>{e.preventDefault();drop.classList.add("dragging");}));
    ["dragleave","drop"].forEach(ev=> drop.addEventListener(ev,e=>{e.preventDefault();drop.classList.remove("dragging");}));
    drop.addEventListener("drop",(e)=>{
      const files = [...(e.dataTransfer.files||[])];
      files.forEach(f=>{ if(f.type.startsWith("image/")) pending.images.push(f); });
      const textData = e.dataTransfer.getData("text/uri-list") || e.dataTransfer.getData("text/plain");
      if(textData){
        (textData.match(/https?:\/\/\S+/g)||[]).forEach(u=>{
          try{ const v=new URL(u); if(/^https?:$/.test(v.protocol)) pending.links.push(v.toString()); }catch(_){}
        });
      }
      refreshPreviews();
    });

    // ----- Upload images to Storage -----
    async function uploadImages(uid, messageId, files){
      const urls=[];
      for(const f of files){
        const path = `hallway_uploads/${uid}/${messageId}/${Date.now()}_${encodeURIComponent(f.name)}`;
        const r = sref(storage, path);
        await new Promise((res,rej)=>{
          const task = uploadBytesResumable(r, f);
          task.on("state_changed", ()=>{}, rej, async ()=>{ res(); });
        });
        const url = await getDownloadURL(r);
        urls.push(url);
      }
      return urls;
    }

    // ----- Send post -----
    form.addEventListener("submit", async (e)=>{
      e.preventDefault();
      const u = auth.currentUser;
      if(!u){ alert("Not signed in yet. Try again in a second."); return; }

      const textVal = (text.value || "").trim();
      const links = pending.links.map(String);

      // Create the shell doc first to get an id
      const shell = await addDoc(COL, {
        uid: u.uid,
        author: u.displayName || "Anonymous",
        text: textVal,
        links,
        images: [],
        createdAt: serverTimestamp()
      });

      // Upload images (if any)
      let images = [];
      if (pending.images.length){
        images = await uploadImages(u.uid, shell.id, pending.images);
        // Patch images array
        await addDoc(collection(db, "hallwayMessages", shell.id, "_patches"), { // lightweight write marker (optional)
          at: serverTimestamp(), type: "imagesUploaded"
        }).catch(()=>{});
        // Update root doc with image URLs
        await (await import("https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js")).updateDoc(
          doc(db, "hallwayMessages", shell.id), { images }
        ).catch(()=>{});
      }

      // reset local inputs
      text.value=""; pending.links = []; pending.images = []; refreshPreviews();

      // Enforce soft cap (client-side)
      try{ await enforceCap(); }catch{}
    });

    // ----- Keep collection size safe -----
    async function enforceCap(){
      const countSnap = await getCountFromServer(COL);
      const total = countSnap.data().count || 0;
      if (total <= MAX_MESSAGES) return;

      const toDelete = total - MAX_MESSAGES;
      const qOldest = query(COL, orderBy("createdAt", "asc"), limit(toDelete));
      const oldSnap = await getDocs(qOldest);
      const batchDel = (await import("https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js")).writeBatch(db);
      oldSnap.forEach(d => batchDel.delete(d.ref));
      await batchDel.commit();
    }

    // Optional TTL cleanup on load (delete messages older than N days)
    window.addEventListener("load", async ()=>{
      if (OPTIONAL_TTL_DAYS > 0){
        const cutoff = new Date(Date.now() - OPTIONAL_TTL_DAYS*24*60*60*1000);
        const qOld = query(COL, where("createdAt","<", cutoff), orderBy("createdAt","asc"), limit(100));
        const snap = await getDocs(qOld);
        if (!snap.empty){
          const mod = await import("https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js");
          const wb = mod.writeBatch(db);
          snap.forEach(d=> wb.delete(d.ref));
          await wb.commit();
        }
      }
    });
  </script>

  <!-- Small helpers that don’t need modules -->
  <script>
    // Enter to send (Shift+Enter makes newline)
    document.addEventListener("keydown", (e)=>{
      const t = document.getElementById("text");
      if (!t || document.activeElement !== t) return;
      if (e.key === "Enter" && !e.shiftKey){
        e.preventDefault();
        document.getElementById("sendBtn").click();
      }
    });
  </script>
</body>
</html>
